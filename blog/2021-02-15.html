<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/main-d6804adfbf3117449937.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/framework.ae602c9f15f1d83ed78e.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/commons.9a012aaea6d9efd8104d.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/pages/_app-26002d4d4b81a28b8175.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/6bcf4aa16b6c25a0abeef7a11a140893ab14bfdd.36ca54daa090651637f1.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/pages/blog/%5Bslug%5D-73dc4c21fda5f970298d.js" as="script"/><style data-styled="" data-styled-version="5.2.1"></style></head><body><div id="__next"></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"객체를 복사하는 방법, JSON.parse(JSON.stringify(Object)) vs 깊은 복사"},"htmlString":"\u003cimg src=\"https://images.unsplash.com/flagged/photo-1582733265415-a0740c8a82fd?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D\u0026ixlib=rb-1.2.1\u0026auto=format\u0026fit=crop\u0026w=1050\u0026q=80\" alt=\"Stairs\" title=\"Stairs\" /\u003e\n\n\u003cp\u003e\u003cspan class=\"photo-reference\"\u003ePhoto by \u003ca href=\"https://unsplash.com/@seimesa?utm_source=unsplash\u0026amp;utm_medium=referral\u0026amp;utm_content=creditCopyText\" target=\"_blank\" rel=\"noopener\"\u003eMario Mesaglio\u003c/a\u003e on \u003ca href=\"https://unsplash.com/s/photos/recursive?utm_source=unsplash\u0026amp;utm_medium=referral\u0026amp;utm_content=creditCopyText\" target=\"_blank\" rel=\"noopener\"\u003eUnsplash\u003c/a\u003e\u003c/span\u003e\u003c/p\u003e\n\u003ch2 id=\"왜-이러지\"\u003e왜 이러지??\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst test = [1, 2, 3, 4, 5];\n\nconst copied = test;\n\ntest.pop();\n\nconsole.log(copied);\n// 기대한 copied의 값\n// [1, 2, 3, 4, 5]\n// 출력되는 copied의 값\n// [1, 2, 3, 4]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecopied는 건들지 않고 test에만 변형을 가했지만 copied에도 그 영향이 미쳤다. 이걸 설명하기 위해서는 \u003ccode\u003e기본형 타입(Primitive Type)\u003c/code\u003e과 \u003ccode\u003e참조형 타입(Reference Type)\u003c/code\u003e의 차이와 주소값에 대한 설명이 필요하지만 이건 나중에 따로 다루겠다. 일단은 자바스크립트에서 배열(Array)은 참조형 타입이고, 참조형 타입은 기본형 타입인 문자열(string)이나 숫자(number)등을 복사하듯이 해서는 복사가 제대로 이뤄지지 않는다는 것만 알면 되겠다. 배열 외에도 참조형 타입에는 Object, Function, Date, RegExp, Map, WeakMap, Set, WeakSet 등이 있다.\u003c/p\u003e\n\u003cp\u003e위의 test같은 1차원 배열은 \u003ccode\u003e얕은 복사\u003c/code\u003e로 복사할 수 있다. 쉽게 말하면 배열 안에 있는 숫자들은 기본형 타입이니 그 단계로 한 단계 내려가 숫자들을 직접 복사하는 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst test = [1, 2, 3, 4, 5];\nconst copied = [];\n\nfor (let i = 0; i \u0026lt; test.length; i++) {\n  const copiedNumber = test[i]; // 기본형 타입의 복사\n  copied.push(copiedNumber);\n}\n\ntest.pop();\nconsole.log(copied);\n// 기대한 copied의 값\n// [1, 2, 3, 4, 5]\n// 출력되는 copied의 값\n// [1, 2, 3, 4, 5]\n// 이제 test.pop()의 효과를 copied가 받지 않는다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e얕은 복사에는 많은 방법이 있다. 위에서처럼 for loop를 사용한 것은 기본형 타입이 복사되는 것을 보여주기 위함이었고, 다음과 같은 방법들이 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst copied = [...test];\n// or\nconst copied = test.slice();\n// or\nconst copied = test.map((num) =\u0026gt; num);\n// or\nconst copied = test.filter(() =\u0026gt; true);\n// 등등...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eslice, map, filter등의 메소드는 새로운 배열을 리턴한다는 성질을 이용한 것인데, 사실 복사만 하려고 이 메소드들을 사용하는 일은 드물다. (그나마 slice정도...)\u003c/p\u003e\n\u003cp\u003e그러면 2차원 배열은 어떨까? 아쉽게도 얕은 복사로는 복사가 되지 않는다. 한 단계 아래로 내려가서 복사를 하더라도 그 한 단계 아래에 있는 것이 또 배열이기 때문에 맨 처음에 언급한 문제가 반복된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst nested = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\nconst copied = [];\n\nfor (let i = 0; i \u0026lt; nested.length; i++) {\n  const copiedNumber = nested[i];\n  copied.push(copiedNumber);\n}\n\nnested.pop();\nconsole.log(copied);\n// 기대한 copied의 값\n// [\n//   [1, 2, 3],\n//   [4, 5, 6],\n//   [7, 8, 9],\n// ];\n// 출력되는 copied의 값\n// [\n//   [1, 2, 3],\n//   [4, 5, 6],\n//   [7, 8, 9],\n// ];\n// 응? 괜찮은거 아닌가? 싶지만...\nnested[2].pop();\nconsole.log(copied);\n// 기대한 copied의 값\n// [\n//   [1, 2, 3],\n//   [4, 5, 6],\n//   [7, 8, 9],\n// ];\n// 출력되는 copied의 값\n// [\n//   [1, 2, 3],\n//   [4, 5, 6],\n//   [7, 8],\n// ];\n// 가장 안쪽을 건들면 또다시 copied가 영향을 받는다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e해결법은 한 단계 더 들어가서 복사하는 것이다. 다이브를 두 번 해보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst nested = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\nconst copied = [];\n\nfor (let i = 0; i \u0026lt; nested.length; i++) {\n  const deep1 = [];\n  for (let j = 0; j \u0026lt; nested[i].length; j++) {\n    const copiedNumber = nested[i][j]; // 기본형 타입의 복사\n    deep1.push(copiedNumber);\n  }\n  copied.push(deep1);\n}\n\nnested[2].pop();\nconsole.log(copied);\n// 기대한 copied의 값\n// [\n//   [1, 2, 3],\n//   [4, 5, 6],\n//   [7, 8, 9],\n// ];\n// 출력되는 copied의 값\n// [\n//   [1, 2, 3],\n//   [4, 5, 6],\n//   [7, 8, 9],\n// ];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에 소개한 방법들을 따르다면 이렇게 되겠다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst copied = [[...nested[0]], [...nested[1]], [...nested[2]]];\n// or\nconst copied = [nested[0].slice(), nested[1].slice(), nested[2].slice()];\n// ... 그만하자. 사실 아무도 이렇게 하지 않는다.\nconst nested = [\n  [1, 2, 3],\n  [1, 2, 3, [4, 5, 6]],\n  [1, 2, 3, [4, 5, 6, [7, 8, 9]]],\n  { name: \u0026quot;Jon\u0026quot;, age: 5, friends: [\u0026quot;Roberto\u0026quot;, \u0026quot;Dominik\u0026quot;, \u0026quot;Gasai Yuno\u0026quot;] },\n  [1, 2, 3, [4, 5, 6, [7, 8, 9]]],\n  [1, 2, 3, [4, 5, 6]],\n  [1, 2, 3],\n];\n// 이런건 어떻게 하려고...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 (기본형 타입이 있는 단계까지) 여러 단계 아래로 내려가 복사해 오는 것을 \u003ccode\u003e깊은 복사\u003c/code\u003e라고 한다. 여러 층으로 된 참조형 타입은 깊은 복사를 해야만 제대로 복사가 된다. 그런데 여기서 자주 언급되는 치트방법이 있는데 바로 \u003ccode\u003eJSON.parse()\u003c/code\u003e와 \u003ccode\u003eJSON.stringify()\u003c/code\u003e를 사용하는 것이다.\u003c/p\u003e\n\u003ch2 id=\"jsonparsejsonstringify\"\u003eJSON.parse(JSON.stringify())\u003c/h2\u003e\n\u003ch3 id=\"장점\"\u003e장점\u003c/h3\u003e\n\u003cp\u003e간편하다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst nested = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n];\n\nconst copied = JSON.parse(JSON.stringify(nested));\n\nnested[2].pop();\nconsole.log(copied);\n// 기대한 copied의 값\n// [\n//   [1, 2, 3],\n//   [4, 5, 6],\n//   [7, 8, 9],\n// ];\n// 출력되는 copied의 값\n// [\n//   [1, 2, 3],\n//   [4, 5, 6],\n//   [7, 8, 9],\n// ];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e깊은 복사를 하는 대신에 객체 자체를 JSON문자열로 바꿨다(stringify)가 다시 객체로 해석(parse)하게끔 하는 방법이다. JSON문자열로 바뀌면서 기존에 있던 주소값들은 전혀 상관이 없게 되고, 이걸 해석할 때 완전히 새로운 주소들에 써진 객체가 된다. 어떻게 보면 인간이 하는 사고방식과 가장 유사한 방법이다.\u003c/p\u003e\n\u003ch3 id=\"단점\"\u003e단점\u003c/h3\u003e\n\u003cp\u003e문제는 장점에 비해 단점이 치명적이라는 것이다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e데이터의 종류에 따라서는 손실 또는 변형될 수 있다.\u003c/li\u003e\n\u003cli\u003e이 가능성을 에러 메시지나 경고 메시지 등으로 전혀 알려주지 않는다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e예시인 nested를 조금 바꿔서 해보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst nested = {\n  name: undefined,\n  sayHello: () =\u0026gt; console.log(\u0026quot;Hello!\u0026quot;),\n};\n\nconst copied = JSON.parse(JSON.stringify(nested));\n\nconsole.log(copied);\n// 기대한 copied의 값\n// {\n//   name: undefined,\n//   sayHello: () =\u0026gt; console.log(\u0026quot;Hello!\u0026quot;)\n// };\n// 출력되는 copied의 값\n// {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아무런 언급도 없이 값들이 그냥 사라져버렸다. 이런 반응을 보이는 데이터 종류에는 위에서 쓴 undefined나 함수, 그리고 Date 객체, Symbol() 등이 있고, NaN이나 Infinity같은 경우에는 null로 바꿔버린다.\u003c/p\u003e\n\u003cp\u003eJSON.parse(JSON.stringify())는 간편하기는 하지만 결코 추천할 수 없는 방법이다.\u003c/p\u003e\n\u003ch2 id=\"깊은-복사recursive\"\u003e깊은 복사(Recursive)\u003c/h2\u003e\n\u003cp\u003e자, 그럼 남은 선택지는 깊은 복사를 하는 것 뿐이다. 10중 배열이건 100중 객체건 기본형 타입이 있는 곳까지 내려가 복사를 해오는 것이다. 하지만 우리가 직접 할 필요는 없다. Javascript에게 일을 시켜보자. 일단 배열일 때만 쓸 수 있는 함수를 만들어 봤다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst nested = [\n  [1, 2, 3],\n  [1, 2, 3, [4, 5, 6]],\n  [1, 2, 3, [4, 5, 6, [7, 8, 9]]],\n  [1, 2, 3, [4, 5, 6, [7, 8, 9]]],\n  [1, 2, 3, [4, 5, 6]],\n  [1, 2, 3],\n]\n\nconst deepCopy = (targetElement) =\u0026gt; {\n  if (!Array.isArray(targetElement)) {\n    return targetElement\n  }\n  const returnArray[] = []\n\n  for (let i = 0; i \u0026lt; targetElement.length; i++) {\n    const element = targetElement[i]\n    const returnElement = deepCopy(element) // recursive!\n    returnArray.push(returnElement)\n  }\n\n  return returnArray\n}\n\nconst copied = deepCopy(nested)\n\nnested[2][3][3].pop()\nconsole.log(copied)\n// 기대한 값\n// [\n//   [1, 2, 3],\n//   [1, 2, 3, [4, 5, 6]],\n//   [1, 2, 3, [4, 5, 6, [7, 8, 9]]],\n//   [1, 2, 3, [4, 5, 6, [7, 8, 9]]],\n//   [1, 2, 3, [4, 5, 6]],\n//   [1, 2, 3],\n// ];\n// 출력되는 값\n// [\n//   [1, 2, 3],\n//   [1, 2, 3, [4, 5, 6]],\n//   [1, 2, 3, [4, 5, 6, [7, 8, 9]]],\n//   [1, 2, 3, [4, 5, 6, [7, 8, 9]]],\n//   [1, 2, 3, [4, 5, 6]],\n//   [1, 2, 3],\n// ];\n// nested의 변화에 영향을 받지 않음.\n// 제대로 복사가 됨.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edeepCopy\u003c/code\u003e함수에서 재밌는 점은 deepCopy함수 내에서 또다시 deepCopy함수를 쓰고 있다는 것이다. 이런 함수를 \u003ccode\u003eRecursive\u003c/code\u003e 함수라고 부르며, 깊은 배열이나 객체 안으로 자바스크립트를 보낼 수 있게 하는 방법이다.\u003c/p\u003e\n\u003cp\u003e쉬운 예시를 들어보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst prison = [[[[[[[[[[\u0026quot;Matt Damon\u0026quot;]]]]]]]]]];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e언제나 그렇듯이 맷 데이먼이 10중 감옥에 갇혀 구출을 기다리고 있다. 하지만 우리의 자바스크립트는 구출 대신 복사를 해 올 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst deepCopy = (targetElement) =\u0026gt; {\n  if (!Array.isArray(targetElement)) {\n    return targetElement\n  }\n  const returnArray[] = []\n\n  for (let i = 0; i \u0026lt; targetElement.length; i++) {\n    const element = targetElement[i]\n    const returnElement = deepCopy(element)\n    returnArray.push(returnElement)\n  }\n\n  return returnArray\n}\n\nconst copied = deepCopy(prison);\n\nprison[0][0][0][0][0][0][0][0][0].pop();\n\nconsole.log(prison);\n// [[[[[[[[[[]]]]]]]]]]\n\nconsole.log(copied);\n// [[[[[[[[[[\u0026quot;Matt Damon\u0026quot;]]]]]]]]]]\n// prison 배열의 변화에 영향을 받지 않음\n// 즉 제대로 복사되어 서로 완전히 다른 배열이 됨\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 for loop는 10중 감옥과 마주치고 deepCopy함수를 다시 실행한다. 이번엔 9중 감옥과 마주치고 다시 deepCopy함수를 실행한다. 그 다음엔 8중 감옥에 대해 deepCopy함수를 실행한다.\u003cbr\u003e이 과정은 deepCopy함수의 첫 번째 줄인 \u003ccode\u003eif (!Array.isArray(targetElement))\u003c/code\u003e에 \u0026quot;Matt Damon\u0026quot;문자열이 걸려 \u003ccode\u003ereturn targetElement\u003c/code\u003e가 실행될 때까지 반복된다. 그 동안 상위의 for loop는 모두 각자의 deepCopy함수가 값을 출력하기를 멈춰서서 기다리고 있다.\u003cbr\u003e\u0026quot;Matt Damon\u0026quot;에 다다르면 이제 가장 나중에 실행된 deepCopy함수부터 \u003ccode\u003ereturn returnArray\u003c/code\u003e을 하기 시작한다(=멈춰서 있던 for loop가 하나씩 loop를 끝낸다). 이 과정을 거쳐서 최종적으로 10중 감옥에 갇힌 Matt Damon이 복사됐다.\u003c/p\u003e\n\u003ch2 id=\"결론\"\u003e결론\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eJSON.parse(JSON.stringify())\u003c/code\u003e는 간편해 보이지만 바람직한 방법은 아니다. Recursive 함수로 깊은 복사를 하는 함수를 만드는 것은 크게 어렵지 않다. 그리고 구글로 검색하면 많은 함수들이 올라와 있어 구하기도 쉬우며, 확실하고 쉬운 방법을 원한다면 \u003ccode\u003eLodash\u003c/code\u003e라는 라이브러리를 사용하는 방법도 있다고 하니(써보진 않았다) JSON.parse(JSON.stringify())의 사용은 자제하도록 하자.\u003c/p\u003e\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"2021-02-15"},"buildId":"nDU7ZYuoJjwlLiKvZ174v","assetPrefix":"/jonganebski-test.github.io","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/jonganebski-test.github.io/_next/static/chunks/polyfills-4f4acd756cef4fe6da1b.js"></script><script src="/jonganebski-test.github.io/_next/static/chunks/main-d6804adfbf3117449937.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/framework.ae602c9f15f1d83ed78e.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/commons.9a012aaea6d9efd8104d.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/pages/_app-26002d4d4b81a28b8175.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/6bcf4aa16b6c25a0abeef7a11a140893ab14bfdd.36ca54daa090651637f1.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/pages/blog/%5Bslug%5D-73dc4c21fda5f970298d.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/nDU7ZYuoJjwlLiKvZ174v/_buildManifest.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/nDU7ZYuoJjwlLiKvZ174v/_ssgManifest.js" async=""></script></body></html>