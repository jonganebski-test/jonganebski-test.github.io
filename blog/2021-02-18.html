<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><noscript data-n-css=""></noscript><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/main-d6804adfbf3117449937.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/framework.ae602c9f15f1d83ed78e.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/commons.4bb54737e576c6d47fcf.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/pages/_app-26002d4d4b81a28b8175.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/6bcf4aa16b6c25a0abeef7a11a140893ab14bfdd.36ca54daa090651637f1.js" as="script"/><link rel="preload" href="/jonganebski-test.github.io/_next/static/chunks/pages/blog/%5Bslug%5D-73dc4c21fda5f970298d.js" as="script"/><style data-styled="" data-styled-version="5.2.1"></style></head><body><div id="__next"></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"간단하고 자그마한 나의 PostgreSQL 명령문들"},"htmlString":"\u003cimg src=\"https://images.unsplash.com/photo-1535077516733-ad29da1026f6?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D\u0026ixlib=rb-1.2.1\u0026auto=format\u0026fit=crop\u0026w=1398\u0026q=80\" alt=\"Elephant\" title=\"Elephant\"\u003e\n\u003cspan class=\"photo-reference\"\u003ePhoto by \u003ca href=\"https://unsplash.com/@davidclode?utm_source=unsplash\u0026amp;utm_medium=referral\u0026amp;utm_content=creditCopyText\"\u003eDavid Clode\u003c/a\u003e on \u003ca href=\"https://unsplash.com/s/photos/baby-elephant?utm_source=unsplash\u0026amp;utm_medium=referral\u0026amp;utm_content=creditCopyText\"\u003eUnsplash\u003c/a\u003e\u003c/span\u003e\n\n\u003cp\u003e명령문을 모두 알고 있지는 않다. 하지만 개인 프로젝트를 진행하면서 가장 빈번하게 사용하게 되는 기본적인 명령어들을 정리해 보고자 한다. 물론 pgAdmin같은 GUI를 사용한다면 필요없겠지만...\u003cbr\u003ewsl2를 사용하고 있으므로 아래의 예시들은 모두 wsl2 환경에서 진행됐다.\u003c/p\u003e\n\u003cp\u003ewsl2에서 postgresql을 실행\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; sudo -u postgres psql\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 \u003ccode\u003epostgres=#\u003c/code\u003e로 표시되는 psql로 들어가게 된다.\u003c/p\u003e\n\u003ch2 id=\"시작하기-전에\"\u003e시작하기 전에...\u003c/h2\u003e\n\u003cp\u003e여기서 몇 가지 일러두자면, 대문자를 쓰는 이유는 SQL명령문임을 강조하기 위해서다. 소문자로 입력하더라고 상관이 없다. 다만 데이터베이스의 종류에 따라서는 그래도 대소문자를 구별해 주는 것이 좋다고 알고 있는데, 적어도 이 포스트 내용에 한해서는 괜찮다.\u003cbr\u003e그리고 명령어 마지막에 항상 \u003ccode\u003e;\u003c/code\u003e을 붙여야 한다. 이거 의외로 실수하기 쉬우니 명심하자. 세미콜론을 붙이지 않으면 명령문이 실행되지 않고 \u003ccode\u003epostgres-#\u003c/code\u003e로 넘어간다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=# SELECT CURRENT_USER (;빼먹음!)\npostgres-#\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e당황하지 말고 \u003ccode\u003e;\u003c/code\u003e을 마저 적고 엔터를 치면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=# SELECT CURRENT_USER (;빼먹음!)\npostgres-# ;\n\ncurrent_user\n--------------\npostgres\n(1 row)\n\npostgres=#\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"create-user-유저이름-with-password-암호\"\u003e\u003ccode\u003eCREATE USER 유저이름 WITH PASSWORD \u0026#39;암호\u0026#39;;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003epostgres는 기본적으로 존재하는 superuser다. 이 유저로 진행해도 개인 사이드 프로젝트 정도라면 별 상관이 없겠지만 그래도 새로운 유저를 등록하는 것이 좋다. 암호를 적을 때에는 작은 따옴표를 써야 된다.(\u003ccode\u003e\u0026#39;\u0026#39;\u003c/code\u003e)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=# CREATE USER 유저이름 WITH PASSWORD \u0026#39;암호\u0026#39;;\n\nCREATE ROLE\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"alter-user-유저이름-with-createdb\"\u003e\u003ccode\u003eALTER USER 유저이름 WITH CREATEDB;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e새로 생성된 유저로 프로젝트를 진행하기 위해서는 이 유저로 데이터베이스를 만들 수 있는 권한을 부여해 줘야 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=# ALTER USER 유저이름 WITH CREATEDB;\n\nALTER ROLE\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"du\"\u003e\u003ccode\u003e\\du\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e이 명령어는 모든 유저들을 보여준다. 우리가 생성한 유저에게 Create DB 라고 데이터베이스를 생성할 수 있는 권한이 부여된 것을 볼 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=# \\du\n\n                                    List of roles\n  Role name  |                         Attributes                         | Member of\n-------------+------------------------------------------------------------+-----------\n postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}\n 유저이름    | Create DB                                                  | {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"set-role-유저이름\"\u003e\u003ccode\u003eSET ROLE 유저이름;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e여기까지는 superuser인 postgres로 진행한 것이다. 이제 방금 생성한 유저로 갈아타 보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=# SET ROLE 유저이름;\n\nSET\n\npostgres=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"select-current_user\"\u003e\u003ccode\u003eSELECT CURRENT_USER;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e지금 사용 중인 유저가 어떤 유저인지 볼 수 있다. 우리가 만든 유저로 무사히 넘어왔음을 볼 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=\u0026gt; SELECT CURRENT_USER;\n\ncurrent_user\n--------------\n유저이름\n(1 row)\n\npostgres=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"create-database-데이터베이스이름\"\u003e\u003ccode\u003eCREATE DATABASE 데이터베이스이름;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e데이터베이스를 만든다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=\u0026gt; CREATE DATABASE 데이터베이스이름;\n\nCREATE DATABASE\n\npostgres=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"l\"\u003e\u003ccode\u003e\\l\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e소문자 엘이다. 대문자가 L인 그 엘. 리스트(list)의 엘. 현재 postgresql의 모든 데이터베이스들을 보여준다. 우리가 만든 데이터베이스 말고도 postgres, template0, template1이 있으면 정상이다. 이것들은 건들지 말자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=\u0026gt; \\l\n\n                                List of databases\n    Name         |    Owner    | Encoding | Collate |  Ctype  |   Access privileges\n-----------------+-------------+----------+---------+---------+-----------------------\n 데이터베이스이름| 유저이름    | UTF8     | C.UTF-8 | C.UTF-8 |\n postgres        | postgres    | UTF8     | C.UTF-8 | C.UTF-8 |\n template0       | postgres    | UTF8     | C.UTF-8 | C.UTF-8 | =c/postgres          +\n                 |             |          |         |         | postgres=CTc/postgres\n template1       | postgres    | UTF8     | C.UTF-8 | C.UTF-8 | =c/postgres          +\n                 |             |          |         |         | postgres=CTc/postgres\n(4 rows)\n\npostgres=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"c\"\u003e\u003ccode\u003e\\c\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e우리가 만든 데이터베이스 안으로 들어가보자. 그런데 postgres로서 들어갔다고 알려준다. 위에서 했던 것처럼 SET ROLE을 사용하여 다시 우리가 만든 유저로 바꿔주자. (그냥 postgres로 진행해도 크게 상관은 없으리라 생각된다)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003epostgres=\u0026gt; \\c 데이터베이스이름\n\nYou are now connected to database \u0026quot;데이터베이스이름\u0026quot; as user \u0026quot;postgres\u0026quot;.\n\n데이터베이스이름=# SET ROLE 유저이름;\n\nSET\n\n데이터베이스이름=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"dt-d\"\u003e\u003ccode\u003e\\dt, \\d\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e\\dt\u003c/code\u003e는 데이터베이스 내의 모든 테이블을 보여준다. \u003ccode\u003e\\d\u003c/code\u003e는 테이블을 포함해서 sequence, view까지 포함해서 보여준다. 아직 아무 테이블이 없다면 Did not find any relations. 라고 뜰 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e데이터베이스이름=\u0026gt; \\dt\n\nDid not find any relations.\n\n데이터베이스이름=\u0026gt; \\d\n\nDid not find any relations.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e테이블을 만드는 명령어는 다루지 않는다. 왜냐하면 쓴 적이 없다. CREATE DATABASE까지만이 우리가 여기서 해줄 일이다. Django를 쓰건 typeORM을 쓰건 테이블은 이들이 model이나 entity에 따라서 자동으로 생성할 것이다. 그래도 다루는 것이 좋지 않겠는가? 하시는 분들도 있겠지만 이 포스트 제목이 \u0026#39;간단하고 자그마한 나의 PostgreSQL 명령문들\u0026#39;이라는 것을 상기하시길...\u003c/p\u003e\n\u003cp\u003e백엔드 프로그램이 성공적으로 실행됐다면 이제 테이블들이 보일 것이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e데이터베이스이름=\u0026gt; \\dt\n\n                         List of relations\n Schema |                Name                | Type  |    Owner\n--------+------------------------------------+-------+-------------\n public | 테이블이름                          | table | 유저이름\n public | 테이블이름                          | table | 유저이름\n public | 테이블이름                          | table | 유저이름\n public | 테이블이름                          | table | 유저이름\n\n(4 rows)\n\n데이터베이스이름=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"select--from-테이블이름\"\u003e\u003ccode\u003eSELECT * FROM 테이블이름;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e테이블 내부의 모든 데이터를 열람한다. 테이터의 양이 많을 경우 끊어서 보여주는데, 엔터키를 누르면 다음 데이터를 보여준다. 중단하고 싶다면 \u003ccode\u003eq\u003c/code\u003e를 누르자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e데이터베이스이름=\u0026gt; SELECT * FROM 데이터베이스이름;\n\n id |         createdAt          |         updatedAt          |         email\n----+----------------------------+----------------------------+------------------------\n  1 | 2020-12-15 16:40:04.031237 | 2020-12-15 19:55:29.938685 | typescript@gmail.com\n  2 | 2020-12-15 20:44:25.582199 | 2020-12-15 20:44:25.582199 | python@gmail.com\n  3 | 2021-01-04 12:29:27.786251 | 2021-01-04 12:29:27.786251 | go@gmail.com\n(3 rows)\n\n데이터베이스이름=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"테이블-이름을-user로-지었을-때\"\u003e테이블 이름을 user로 지었을 때\u003c/h2\u003e\n\u003cp\u003e보통 유저들의 model이나 entity의 이름을 user라고 짓는데, 문제는 user는 postgresql에서도 사용하고 있다는 것이다. user라는 테이블을 만들었다고 가정하면,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e데이터베이스이름=\u0026gt; SELECT * FROM user;\n\nuser\n----------\n유저네임\n(1 row)\n\n데이터베이스이름=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e내 테이블의 데이터 대신 현재 사용중인 postgresql 유저가 나온다. 그래서 나는 보통 user대신 users로 model을 정의하는 편이다. 아니면 쌍따옴표로 \u0026quot;user\u0026quot;라고 써주면 내 user테이블을 보여준다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e데이터베이스이름=\u0026gt; SELECT * FROM \u0026quot;user\u0026quot;;\n\n id |         createdAt          |         updatedAt          |         email\n----+----------------------------+----------------------------+------------------------\n  1 | 2020-12-15 16:40:04.031237 | 2020-12-15 19:55:29.938685 | typescript@gmail.com\n  2 | 2020-12-15 20:44:25.582199 | 2020-12-15 20:44:25.582199 | python@gmail.com\n  3 | 2021-01-04 12:29:27.786251 | 2021-01-04 12:29:27.786251 | go@gmail.com\n(3 rows)\n\n데이터베이스이름=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"delete-from-테이블이름-where-조건\"\u003e\u003ccode\u003eDELETE FROM 테이블이름 WHERE 조건;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e위의 user 테이블로 진행하겠다. 테이블 내의 row 중 조건을 충족하는 row를 삭제하는 명령이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e데이터베이스이름=\u0026gt; DELETE FROM \u0026quot;user\u0026quot; WHERE id=3;\n\nDELETE 1\n\n데이터베이스이름=\u0026gt; SELECT * FROM \u0026quot;user\u0026quot;;\n\n id |         createdAt          |         updatedAt          |         email\n----+----------------------------+----------------------------+------------------------\n  1 | 2020-12-15 16:40:04.031237 | 2020-12-15 19:55:29.938685 | typescript@gmail.com\n  2 | 2020-12-15 20:44:25.582199 | 2020-12-15 20:44:25.582199 | python@gmail.com\n(2 rows)\n\n데이터베이스이름=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"delete-from-테이블이름\"\u003e\u003ccode\u003eDELETE FROM 테이블이름;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e테이블의 모든 row를 지운다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e데이터베이스이름=\u0026gt; DELETE FROM \u0026quot;user\u0026quot;;\n\nDELETE 2\n\n데이터베이스이름=\u0026gt; SELECT * from \u0026quot;user\u0026quot;;\n\n id | createdAt | updatedAt | email\n----+-----------+-----------+-------\n(0 rows)\n\n데이터베이스이름=\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"drop-database-데이터베이스이름\"\u003e\u003ccode\u003eDROP DATABASE 데이터베이스이름;\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e데이터베이스를 통째로 삭제한다. 주의해서 사용해야 된다. 해당 데이터베이스 내에서 삭제하는 것은 불가능하므로 다른 데이터베이스로 나가야 된다. 기본 데이터베이스인 postgres로 이동한 뒤 명령어를 실행해 보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e데이터베이스이름=\u0026gt; \\c postgres\n\npostgres=# DROP DATABASE 데이터베이스이름;\n\nDROP DATABASE\n\npostgres=#\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"마치며\"\u003e마치며\u003c/h2\u003e\n\u003cp\u003e내가 자주 사용하는 PostgreSQL 명령어들을 적어봤다. 현재로서는 매우 기본적인 수준이다. typeORM 로그로 지나가는 무수한 SQL문을 언젠가는 모두 알아들을 수 있는 날이 오기를 바란다.\u003c/p\u003e\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"2021-02-18"},"buildId":"TcgpfmACRT7sP5-HIJlwM","assetPrefix":"/jonganebski-test.github.io","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/jonganebski-test.github.io/_next/static/chunks/polyfills-4f4acd756cef4fe6da1b.js"></script><script src="/jonganebski-test.github.io/_next/static/chunks/main-d6804adfbf3117449937.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/framework.ae602c9f15f1d83ed78e.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/commons.4bb54737e576c6d47fcf.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/pages/_app-26002d4d4b81a28b8175.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/6bcf4aa16b6c25a0abeef7a11a140893ab14bfdd.36ca54daa090651637f1.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/chunks/pages/blog/%5Bslug%5D-73dc4c21fda5f970298d.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/TcgpfmACRT7sP5-HIJlwM/_buildManifest.js" async=""></script><script src="/jonganebski-test.github.io/_next/static/TcgpfmACRT7sP5-HIJlwM/_ssgManifest.js" async=""></script></body></html>