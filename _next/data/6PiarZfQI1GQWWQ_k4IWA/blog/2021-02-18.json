{"pageProps":{"currentPost":{"frontmatter":{"title":"간단하고 자그마한 나의 PostgreSQL 명령문들"},"htmlString":"<img src=\"https://images.unsplash.com/photo-1535077516733-ad29da1026f6?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1398&q=80\" alt=\"Elephant\" title=\"Elephant\">\n<span class=\"photo-reference\">Photo by <a href=\"https://unsplash.com/@davidclode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">David Clode</a> on <a href=\"https://unsplash.com/s/photos/baby-elephant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a></span>\n\n<p>명령문을 모두 알고 있지는 않다. 하지만 개인 프로젝트를 진행하면서 가장 빈번하게 사용하게 되는 기본적인 명령어들을 정리해 보고자 한다. 물론 pgAdmin같은 GUI를 사용한다면 필요없겠지만...<br>wsl2를 사용하고 있으므로 아래의 예시들은 모두 wsl2 환경에서 진행됐다.</p>\n<p>wsl2에서 postgresql을 실행</p>\n<pre><code>&gt; sudo -u postgres psql\n</code></pre>\n<p>그러면 <code>postgres=#</code>로 표시되는 psql로 들어가게 된다.</p>\n<h2 id=\"시작하기-전에\">시작하기 전에...</h2>\n<p>여기서 몇 가지 일러두자면, 대문자를 쓰는 이유는 SQL명령문임을 강조하기 위해서다. 소문자로 입력하더라고 상관이 없다. 다만 데이터베이스의 종류에 따라서는 그래도 대소문자를 구별해 주는 것이 좋다고 알고 있는데, 적어도 이 포스트 내용에 한해서는 괜찮다.<br>그리고 명령어 마지막에 항상 <code>;</code>을 붙여야 한다. 이거 의외로 실수하기 쉬우니 명심하자. 세미콜론을 붙이지 않으면 명령문이 실행되지 않고 <code>postgres-#</code>로 넘어간다.</p>\n<pre><code class=\"language-sql\">postgres=# SELECT CURRENT_USER (;빼먹음!)\npostgres-#\n</code></pre>\n<p>당황하지 말고 <code>;</code>을 마저 적고 엔터를 치면 된다.</p>\n<pre><code class=\"language-sql\">postgres=# SELECT CURRENT_USER (;빼먹음!)\npostgres-# ;\n\ncurrent_user\n--------------\npostgres\n(1 row)\n\npostgres=#\n</code></pre>\n<h2 id=\"create-user-유저이름-with-password-암호\"><code>CREATE USER 유저이름 WITH PASSWORD &#39;암호&#39;;</code></h2>\n<p>postgres는 기본적으로 존재하는 superuser다. 이 유저로 진행해도 개인 사이드 프로젝트 정도라면 별 상관이 없겠지만 그래도 새로운 유저를 등록하는 것이 좋다. 암호를 적을 때에는 작은 따옴표를 써야 된다.(<code>&#39;&#39;</code>)</p>\n<pre><code class=\"language-sql\">postgres=# CREATE USER 유저이름 WITH PASSWORD &#39;암호&#39;;\n\nCREATE ROLE\n</code></pre>\n<h2 id=\"alter-user-유저이름-with-createdb\"><code>ALTER USER 유저이름 WITH CREATEDB;</code></h2>\n<p>새로 생성된 유저로 프로젝트를 진행하기 위해서는 이 유저로 데이터베이스를 만들 수 있는 권한을 부여해 줘야 된다.</p>\n<pre><code class=\"language-sql\">postgres=# ALTER USER 유저이름 WITH CREATEDB;\n\nALTER ROLE\n</code></pre>\n<h2 id=\"du\"><code>\\du</code></h2>\n<p>이 명령어는 모든 유저들을 보여준다. 우리가 생성한 유저에게 Create DB 라고 데이터베이스를 생성할 수 있는 권한이 부여된 것을 볼 수 있다.</p>\n<pre><code class=\"language-sql\">postgres=# \\du\n\n                                    List of roles\n  Role name  |                         Attributes                         | Member of\n-------------+------------------------------------------------------------+-----------\n postgres    | Superuser, Create role, Create DB, Replication, Bypass RLS | {}\n 유저이름    | Create DB                                                  | {}\n</code></pre>\n<h2 id=\"set-role-유저이름\"><code>SET ROLE 유저이름;</code></h2>\n<p>여기까지는 superuser인 postgres로 진행한 것이다. 이제 방금 생성한 유저로 갈아타 보자.</p>\n<pre><code class=\"language-sql\">postgres=# SET ROLE 유저이름;\n\nSET\n\npostgres=&gt;\n</code></pre>\n<h2 id=\"select-current_user\"><code>SELECT CURRENT_USER;</code></h2>\n<p>지금 사용 중인 유저가 어떤 유저인지 볼 수 있다. 우리가 만든 유저로 무사히 넘어왔음을 볼 수 있다.</p>\n<pre><code class=\"language-sql\">postgres=&gt; SELECT CURRENT_USER;\n\ncurrent_user\n--------------\n유저이름\n(1 row)\n\npostgres=&gt;\n</code></pre>\n<h2 id=\"create-database-데이터베이스이름\"><code>CREATE DATABASE 데이터베이스이름;</code></h2>\n<p>데이터베이스를 만든다.</p>\n<pre><code class=\"language-sql\">postgres=&gt; CREATE DATABASE 데이터베이스이름;\n\nCREATE DATABASE\n\npostgres=&gt;\n</code></pre>\n<h2 id=\"l\"><code>\\l</code></h2>\n<p>소문자 엘이다. 대문자가 L인 그 엘. 리스트(list)의 엘. 현재 postgresql의 모든 데이터베이스들을 보여준다. 우리가 만든 데이터베이스 말고도 postgres, template0, template1이 있으면 정상이다. 이것들은 건들지 말자.</p>\n<pre><code class=\"language-sql\">postgres=&gt; \\l\n\n                                List of databases\n    Name         |    Owner    | Encoding | Collate |  Ctype  |   Access privileges\n-----------------+-------------+----------+---------+---------+-----------------------\n 데이터베이스이름| 유저이름    | UTF8     | C.UTF-8 | C.UTF-8 |\n postgres        | postgres    | UTF8     | C.UTF-8 | C.UTF-8 |\n template0       | postgres    | UTF8     | C.UTF-8 | C.UTF-8 | =c/postgres          +\n                 |             |          |         |         | postgres=CTc/postgres\n template1       | postgres    | UTF8     | C.UTF-8 | C.UTF-8 | =c/postgres          +\n                 |             |          |         |         | postgres=CTc/postgres\n(4 rows)\n\npostgres=&gt;\n</code></pre>\n<h2 id=\"c\"><code>\\c</code></h2>\n<p>우리가 만든 데이터베이스 안으로 들어가보자. 그런데 postgres로서 들어갔다고 알려준다. 위에서 했던 것처럼 SET ROLE을 사용하여 다시 우리가 만든 유저로 바꿔주자. (그냥 postgres로 진행해도 크게 상관은 없으리라 생각된다)</p>\n<pre><code class=\"language-sql\">postgres=&gt; \\c 데이터베이스이름\n\nYou are now connected to database &quot;데이터베이스이름&quot; as user &quot;postgres&quot;.\n\n데이터베이스이름=# SET ROLE 유저이름;\n\nSET\n\n데이터베이스이름=&gt;\n</code></pre>\n<h2 id=\"dt-d\"><code>\\dt, \\d</code></h2>\n<p><code>\\dt</code>는 데이터베이스 내의 모든 테이블을 보여준다. <code>\\d</code>는 테이블을 포함해서 sequence, view까지 포함해서 보여준다. 아직 아무 테이블이 없다면 Did not find any relations. 라고 뜰 것이다.</p>\n<pre><code class=\"language-sql\">데이터베이스이름=&gt; \\dt\n\nDid not find any relations.\n\n데이터베이스이름=&gt; \\d\n\nDid not find any relations.\n</code></pre>\n<p>테이블을 만드는 명령어는 다루지 않는다. 왜냐하면 쓴 적이 없다. CREATE DATABASE까지만이 우리가 여기서 해줄 일이다. Django를 쓰건 typeORM을 쓰건 테이블은 이들이 model이나 entity에 따라서 자동으로 생성할 것이다. 그래도 다루는 것이 좋지 않겠는가? 하시는 분들도 있겠지만 이 포스트 제목이 &#39;간단하고 자그마한 나의 PostgreSQL 명령문들&#39;이라는 것을 상기하시길...</p>\n<p>백엔드 프로그램이 성공적으로 실행됐다면 이제 테이블들이 보일 것이다.</p>\n<pre><code class=\"language-sql\">데이터베이스이름=&gt; \\dt\n\n                         List of relations\n Schema |                Name                | Type  |    Owner\n--------+------------------------------------+-------+-------------\n public | 테이블이름                          | table | 유저이름\n public | 테이블이름                          | table | 유저이름\n public | 테이블이름                          | table | 유저이름\n public | 테이블이름                          | table | 유저이름\n\n(4 rows)\n\n데이터베이스이름=&gt;\n</code></pre>\n<h2 id=\"select--from-테이블이름\"><code>SELECT * FROM 테이블이름;</code></h2>\n<p>테이블 내부의 모든 데이터를 열람한다. 테이터의 양이 많을 경우 끊어서 보여주는데, 엔터키를 누르면 다음 데이터를 보여준다. 중단하고 싶다면 <code>q</code>를 누르자.</p>\n<pre><code class=\"language-sql\">데이터베이스이름=&gt; SELECT * FROM 데이터베이스이름;\n\n id |         createdAt          |         updatedAt          |         email\n----+----------------------------+----------------------------+------------------------\n  1 | 2020-12-15 16:40:04.031237 | 2020-12-15 19:55:29.938685 | typescript@gmail.com\n  2 | 2020-12-15 20:44:25.582199 | 2020-12-15 20:44:25.582199 | python@gmail.com\n  3 | 2021-01-04 12:29:27.786251 | 2021-01-04 12:29:27.786251 | go@gmail.com\n(3 rows)\n\n데이터베이스이름=&gt;\n</code></pre>\n<h2 id=\"테이블-이름을-user로-지었을-때\">테이블 이름을 user로 지었을 때</h2>\n<p>보통 유저들의 model이나 entity의 이름을 user라고 짓는데, 문제는 user는 postgresql에서도 사용하고 있다는 것이다. user라는 테이블을 만들었다고 가정하면,</p>\n<pre><code class=\"language-sql\">데이터베이스이름=&gt; SELECT * FROM user;\n\nuser\n----------\n유저네임\n(1 row)\n\n데이터베이스이름=&gt;\n</code></pre>\n<p>내 테이블의 데이터 대신 현재 사용중인 postgresql 유저가 나온다. 그래서 나는 보통 user대신 users로 model을 정의하는 편이다. 아니면 쌍따옴표로 &quot;user&quot;라고 써주면 내 user테이블을 보여준다.</p>\n<pre><code class=\"language-sql\">데이터베이스이름=&gt; SELECT * FROM &quot;user&quot;;\n\n id |         createdAt          |         updatedAt          |         email\n----+----------------------------+----------------------------+------------------------\n  1 | 2020-12-15 16:40:04.031237 | 2020-12-15 19:55:29.938685 | typescript@gmail.com\n  2 | 2020-12-15 20:44:25.582199 | 2020-12-15 20:44:25.582199 | python@gmail.com\n  3 | 2021-01-04 12:29:27.786251 | 2021-01-04 12:29:27.786251 | go@gmail.com\n(3 rows)\n\n데이터베이스이름=&gt;\n</code></pre>\n<h2 id=\"delete-from-테이블이름-where-조건\"><code>DELETE FROM 테이블이름 WHERE 조건;</code></h2>\n<p>위의 user 테이블로 진행하겠다. 테이블 내의 row 중 조건을 충족하는 row를 삭제하는 명령이다.</p>\n<pre><code class=\"language-sql\">데이터베이스이름=&gt; DELETE FROM &quot;user&quot; WHERE id=3;\n\nDELETE 1\n\n데이터베이스이름=&gt; SELECT * FROM &quot;user&quot;;\n\n id |         createdAt          |         updatedAt          |         email\n----+----------------------------+----------------------------+------------------------\n  1 | 2020-12-15 16:40:04.031237 | 2020-12-15 19:55:29.938685 | typescript@gmail.com\n  2 | 2020-12-15 20:44:25.582199 | 2020-12-15 20:44:25.582199 | python@gmail.com\n(2 rows)\n\n데이터베이스이름=&gt;\n</code></pre>\n<h2 id=\"delete-from-테이블이름\"><code>DELETE FROM 테이블이름;</code></h2>\n<p>테이블의 모든 row를 지운다.</p>\n<pre><code class=\"language-sql\">데이터베이스이름=&gt; DELETE FROM &quot;user&quot;;\n\nDELETE 2\n\n데이터베이스이름=&gt; SELECT * from &quot;user&quot;;\n\n id | createdAt | updatedAt | email\n----+-----------+-----------+-------\n(0 rows)\n\n데이터베이스이름=&gt;\n</code></pre>\n<h2 id=\"drop-database-데이터베이스이름\"><code>DROP DATABASE 데이터베이스이름;</code></h2>\n<p>데이터베이스를 통째로 삭제한다. 주의해서 사용해야 된다. 해당 데이터베이스 내에서 삭제하는 것은 불가능하므로 다른 데이터베이스로 나가야 된다. 기본 데이터베이스인 postgres로 이동한 뒤 명령어를 실행해 보자.</p>\n<pre><code class=\"language-sql\">데이터베이스이름=&gt; \\c postgres\n\npostgres=# DROP DATABASE 데이터베이스이름;\n\nDROP DATABASE\n\npostgres=#\n</code></pre>\n<h2 id=\"마치며\">마치며</h2>\n<p>내가 자주 사용하는 PostgreSQL 명령어들을 적어봤다. 현재로서는 매우 기본적인 수준이다. typeORM 로그로 지나가는 무수한 SQL문을 언젠가는 모두 알아들을 수 있는 날이 오기를 바란다.</p>\n"},"prevPost":null,"nextPost":{"slug":"2021-02-15","frontmatter":{"title":"객체를 복사하는 방법, JSON.parse(JSON.stringify(Object)) vs 깊은 복사"}}},"__N_SSG":true}